"""
Main entry point for the LLM Risk Game application.
Allows for console-based configuration of players and AI types.
"""
from llm_risk.game_orchestrator import GameOrchestrator
from dotenv import load_dotenv

# Define available AI types and colors
AVAILABLE_AI_TYPES = ["OpenAI", "Gemini", "Claude", "DeepSeek","Llama","Mistral","Qwen"] # Add "Human" if you implement human players
AVAILABLE_COLORS = ["Red", "Blue", "Green", "Yellow", "Purple", "Orange"]

def get_player_configurations_from_console():
    """
    Prompts the user in the console to define player configurations.
    Returns a list of player configuration dictionaries or None if skipped.
    """
    print("\n--- LLM Risk Game Setup ---")
    print("Configure players and AI types. Press Enter at the first prompt to skip and use default player_config.json.")

    while True:
        try:
            num_players_str = input(f"Enter number of players (2-{len(AVAILABLE_COLORS)}, or 0 to skip): ").strip()
            if not num_players_str: # User pressed Enter
                print("Skipping console configuration. Using default player_config.json.")
                return None

            num_players = int(num_players_str)
            if num_players == 0:
                print("Skipping console configuration. Using default player_config.json.")
                return None
            if 2 <= num_players <= len(AVAILABLE_COLORS):
                break
            else:
                print(f"Please enter a number between 2 and {len(AVAILABLE_COLORS)}.")
        except ValueError:
            print("Invalid input. Please enter a number.")

    player_configs = []
    used_names = set()
    used_colors = set()

    for i in range(num_players):
        print(f"\n--- Configuring Player {i+1} ---")

        # Player Name is now auto-generated by GameOrchestrator as "Player {i+1}"
        # We still need to collect AI type and color if desired.

        # For display purposes during console setup, we can use the generated name.
        generated_player_name = f"Player {i+1}"
        print(f"\n--- Configuring {generated_player_name} ---")

        # AI Type
        print("Available AI types:")
        for idx, ai_type in enumerate(AVAILABLE_AI_TYPES):
            print(f"  {idx + 1}. {ai_type}")

        while True:
            try:
                ai_choice_str = input(f"Choose AI type for {generated_player_name} (number): ").strip()
                ai_choice = int(ai_choice_str) - 1
                if 0 <= ai_choice < len(AVAILABLE_AI_TYPES):
                    selected_ai_type = AVAILABLE_AI_TYPES[ai_choice]
                    break
                else:
                    print(f"Invalid choice. Please enter a number between 1 and {len(AVAILABLE_AI_TYPES)}.")
            except ValueError:
                print("Invalid input. Please enter a number.")

        # Assign Color (can be made a choice later if desired, or taken from config)
        # For now, let's keep the automatic color assignment here for console config,
        # but GameOrchestrator will use its default list if color is missing from player_configs item.
        player_color = AVAILABLE_COLORS[i % len(AVAILABLE_COLORS)]
        if player_color in used_colors:
            for c_fallback in AVAILABLE_COLORS: # Simple fallback for console uniqueness if needed
                if c_fallback not in used_colors:
                    player_color = c_fallback
                    break
        used_colors.add(player_color)

        # The 'name' field is not strictly needed here anymore for GameOrchestrator,
        # as it generates "Player X". We can omit it or pass a placeholder.
        # For clarity, we'll pass the config without 'name' or with the generated name
        # if other parts of the system (e.g. future human player UI) might use it before orchestrator overrides.
        # Let's pass what we have, orchestrator will ignore/override name.
        player_configs.append({
            # "name": generated_player_name, # Orchestrator will generate "Player X"
            "color": player_color, # Orchestrator will use this if present
            "ai_type": selected_ai_type
        })
        print(f"{generated_player_name} will be configured as {selected_ai_type} with color {player_color}.")

    return player_configs

def main():
    """
    Initializes and runs the LLM Risk game.
    Allows for console-based player configuration.
    """
    print("LLM Risk Game - Main Application Starting...")
    load_dotenv()

    # --- Bypassing console input for automated testing ---
    # custom_player_configs = get_player_configurations_from_console()
    custom_player_configs = [
        {"name": "PlayerA (Gemini)", "color": "Red", "ai_type": "Gemini"},
        {"name": "PlayerB (OpenAI)", "color": "Blue", "ai_type": "OpenAI"}
    ]
    print("Using hardcoded 2-player configuration for testing.")

    # Game Mode Selection
    # game_mode_choice_str = input("Choose game mode (1 or 2, default 1): ").strip()
    game_mode_choice_str = "2" # Defaulting to Truthful World Map for this test
    print(f"Hardcoded game mode choice: {game_mode_choice_str}")

    game_mode = "standard"
    # map_file_for_engine is now handled by GameOrchestrator based on game_mode

    if game_mode_choice_str == "2":
        game_mode = "world_map"
        # map_file_for_engine = "world_map_config.json" # Orchestrator handles this
        print("Selected Truthful World Map mode.")
    else:
        print("Selected Standard Risk mode.")
    # --- End of bypass ---

    # Instantiate the GameOrchestrator.
    # The GameOrchestrator's __init__ will now handle the map_file based on game_mode.
    if custom_player_configs: # This will be true due to hardcoding above
        print("\nUsing hardcoded player configurations for testing.")
        orchestrator = GameOrchestrator(
            game_mode=game_mode, # Pass the selected game_mode
            player_configs_override=custom_player_configs
        )
    else:
        # This branch will not be hit with the current hardcoding but kept for structure
        print("\nUsing default player configurations (player_config.json).")
        orchestrator = GameOrchestrator(
            game_mode=game_mode # Pass the selected game_mode
        )

    # Run the game.
    orchestrator.run_game()

    print("LLM Risk Game - Application Finished.")

if __name__ == "__main__":
    main()
