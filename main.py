"""
Main entry point for the LLM Risk Game application.
Allows for console-based configuration of players and AI types.
"""
from llm_risk.game_orchestrator import GameOrchestrator
from dotenv import load_dotenv
import os

# Define available AI types and colors
AVAILABLE_AI_TYPES = ["OpenAI", "Gemini", "Claude", "DeepSeek","Llama","Mistral","Qwen"] # Add "Human" if you implement human players
AVAILABLE_COLORS = ["Red", "Blue", "Green", "Yellow", "Purple", "Orange"]

def get_player_configurations_from_console():
    """
    Prompts the user in the console to define player configurations.
    Returns a list of player configuration dictionaries or None if skipped.
    """
    print("\n--- LLM Risk Game Setup ---")
    print("Configure players and AI types. Press Enter at the first prompt to skip and use default player_config.json.")

    while True:
        try:
            num_players_str = input(f"Enter number of players (2-{len(AVAILABLE_COLORS)}, or 0 to skip): ").strip()
            if not num_players_str: # User pressed Enter
                print("Skipping console configuration. Using default player_config.json.")
                return None

            num_players = int(num_players_str)
            if num_players == 0:
                print("Skipping console configuration. Using default player_config.json.")
                return None
            if 2 <= num_players <= len(AVAILABLE_COLORS):
                break
            else:
                print(f"Please enter a number between 2 and {len(AVAILABLE_COLORS)}.")
        except ValueError:
            print("Invalid input. Please enter a number.")

    player_configs = []
    used_names = set()
    used_colors = set()

    for i in range(num_players):
        print(f"\n--- Configuring Player {i+1} ---")

        # Player Name is now auto-generated by GameOrchestrator as "Player {i+1}"
        # We still need to collect AI type and color if desired.

        # For display purposes during console setup, we can use the generated name.
        generated_player_name = f"Player {i+1}"
        print(f"\n--- Configuring {generated_player_name} ---")

        # AI Type
        print("Available AI types:")
        for idx, ai_type in enumerate(AVAILABLE_AI_TYPES):
            print(f"  {idx + 1}. {ai_type}")

        while True:
            try:
                ai_choice_str = input(f"Choose AI type for {generated_player_name} (number): ").strip()
                ai_choice = int(ai_choice_str) - 1
                if 0 <= ai_choice < len(AVAILABLE_AI_TYPES):
                    selected_ai_type = AVAILABLE_AI_TYPES[ai_choice]
                    break
                else:
                    print(f"Invalid choice. Please enter a number between 1 and {len(AVAILABLE_AI_TYPES)}.")
            except ValueError:
                print("Invalid input. Please enter a number.")

        # Assign Color (can be made a choice later if desired, or taken from config)
        # For now, let's keep the automatic color assignment here for console config,
        # but GameOrchestrator will use its default list if color is missing from player_configs item.
        player_color = AVAILABLE_COLORS[i % len(AVAILABLE_COLORS)]
        if player_color in used_colors:
            for c_fallback in AVAILABLE_COLORS: # Simple fallback for console uniqueness if needed
                if c_fallback not in used_colors:
                    player_color = c_fallback
                    break
        used_colors.add(player_color)

        # The 'name' field is not strictly needed here anymore for GameOrchestrator,
        # as it generates "Player X". We can omit it or pass a placeholder.
        # For clarity, we'll pass the config without 'name' or with the generated name
        # if other parts of the system (e.g. future human player UI) might use it before orchestrator overrides.
        # Let's pass what we have, orchestrator will ignore/override name.
        player_configs.append({
            # "name": generated_player_name, # Orchestrator will generate "Player X"
            "color": player_color, # Orchestrator will use this if present
            "ai_type": selected_ai_type
        })
        print(f"{generated_player_name} will be configured as {selected_ai_type} with color {player_color}.")

    return player_configs

def main():
    """
    Initializes and runs the LLM Risk game.
    Allows for console-based player configuration.
    """
    print("LLM Risk Game - Main Application Starting...")
    load_dotenv()
    custom_player_configs = get_player_configurations_from_console()

    # Instantiate the GameOrchestrator.
    # If custom_player_configs is None, GameOrchestrator will use its default player_config.json.
    # Otherwise, it will use the configurations provided by the user.
    # This requires GameOrchestrator to be modified to accept this parameter.

    # Add argparse for game_mode
    import argparse
    parser = argparse.ArgumentParser(description="Run the LLM Risk Game.")
    parser.add_argument(
        "--game_mode",
        type=str,
        default=None, # Default to None, so we can check if it was set
        choices=["standard", "world_map"],
        help="Game mode to play: 'standard' or 'world_map'. If not provided, you will be prompted."
    )
    parser.add_argument(
        "--geojson_file",
        type=str,
        default=None,
        help="Path to the GeoJSON file for 'world_map' mode. If not provided and world_map is chosen interactively, 'map_display_config_polygons.json' will be used."
    )
    # map_file argument is less relevant now if game_mode dictates everything, but keep for potential standard mode overrides
    parser.add_argument(
        "--map_file",
        type=str,
        default="map_config.json",
        help="Path to the JSON file with map configuration (primarily for 'standard' mode if explicitly specified)."
    )
    args = parser.parse_args()

    selected_game_mode = args.game_mode
    geojson_data_str = None

    if not selected_game_mode:
        print("\n--- Choose Game Mode ---")
        print("1. Standard Risk Game")
        print("2. World Map Game")
        while True:
            choice = input("Enter choice (1 or 2): ").strip()
            if choice == '1':
                selected_game_mode = "standard"
                break
            elif choice == '2':
                selected_game_mode = "world_map"
                break
            else:
                print("Invalid choice. Please enter 1 or 2.")

    print(f"Selected game mode: {selected_game_mode}")

    if selected_game_mode == "world_map":
        # If geojson_file is provided via CLI, use that
        if args.geojson_file:
            if os.path.exists(args.geojson_file):
                try:
                    with open(args.geojson_file, 'r', encoding='utf-8') as f:
                        geojson_data_str = f.read()
                    # print(f"DEBUG: main.py - Loaded GeoJSON data from specified file: {args.geojson_file}. Length: {len(geojson_data_str)}")
                except Exception as e:
                    print(f"Error reading specified GeoJSON file '{args.geojson_file}': {e}. Exiting.")
                    return 1 # Indicate error
            else:
                print(f"Error: Specified GeoJSON file '{args.geojson_file}' not found. Exiting.")
                return 1 # Indicate error
        else:
            # If no geojson_file via CLI, and world_map was chosen (interactively or CLI without file),
            # try to load 'map_display_config_polygons.json' from root.
            default_geojson_filename = "map_display_config_polygons.json"
            if os.path.exists(default_geojson_filename):
                try:
                    with open(default_geojson_filename, 'r', encoding='utf-8') as f:
                        geojson_data_str = f.read()
                    # print(f"DEBUG: main.py - Loaded GeoJSON data from default file: {default_geojson_filename}. Length: {len(geojson_data_str)}")
                except Exception as e:
                    print(f"Error reading default GeoJSON file '{default_geojson_filename}': {e}. Exiting.")
                    return 1
            else:
                print(f"Error: 'world_map' mode selected, but default GeoJSON file '{default_geojson_filename}' not found in root directory and no --geojson_file provided. Exiting.")
                return 1 # Indicate error

        if not geojson_data_str: # Should be caught above, but as a safeguard
            print(f"Critical Error: GeoJSON data string is empty for world_map mode. Exiting.")
            return 1
    # else:
        # print(f"DEBUG: main.py - Not in 'world_map' mode, geojson_data_str will be None.")


    if custom_player_configs:
        print(f"\nUsing custom player configurations from console for {selected_game_mode} mode.")
        orchestrator = GameOrchestrator(
            player_configs_override=custom_player_configs,
            game_mode=selected_game_mode,
            geojson_data_str=geojson_data_str # Will be None if not world_map mode
        )
    else:
        print(f"\nUsing default player configurations (from player_config.json or internal default) for {selected_game_mode} mode.")
        orchestrator = GameOrchestrator(
            game_mode=selected_game_mode,
            geojson_data_str=geojson_data_str # Will be None if not world_map mode
        )

    # Run the game.
    orchestrator.run_game()

    print("LLM Risk Game - Application Finished.")

if __name__ == "__main__":
    main()
